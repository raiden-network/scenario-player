"""Helper module for configuring, starting and stopping Raiden Clients."""
import enum
import pathlib
import socket
from typing import List, Optional, Union

import structlog
from eth_utils.address import to_checksum_address
from eth_utils.typing import ChecksumAddress

from scenario_player.scenario import ScenarioYAML
from scenario_player.setup.nodes.utils import RaidenExecutable, create_keystore
from scenario_player.utils.types import NetlocWithPort

log = structlog.getLogger(__name__)


class OPTION_TYPE(enum.Enum):
    """Sentinel Enum used to detect CLI options without nargs (switches) and missing options."""

    #: The option wasn't stated in the scenario definition file.
    MISSING = f"MISSING_{object()!r}"

    #: The option had either a bool or None value, and therefore qualifies as a switch.
    SWITCH = f"SWITCH_{object()!r}"


class RaidenFlags:
    """Raiden Client flag options.

    Exposes common attributes of the client, and offers simplified
    configuration options.

    Exposes a :meth:`.as_cli_command` method, which converts its attributes into
    a :class:`scenario_player.setup.nodes.executor.RaidenClientExecutor` compatible
    command list.

    By default, we do not check if configured CLI flags in a scenario definition
    file are supported by the Raiden client.

    While all CLI flags are eligible for configuration, there is a set of
    cli flags that are set implicitly by the scenario player, and cannot be
    overridden using options in `<ScenarioYAML>.nodes`:

        - --datadir
        - --log-file
        - --network-id
        - --address*
        - --keystore-path*
        - --password-file*

    Flags marked with `*` are not configurable at all, all others are either loaded
    from cli flags passed to the `scenario_player` command, or configured in
    another section of the scenario definition file (such as `gas-price` in
    `<ScenarioYAML>.settings`, and `network-id` via the `--chain` cli flag).
    """

    #: The list of CLI switches which are always passed when starting a Raiden Node,
    #: and cannot be overridden in a scenario definition file (if given, they'll
    #: be ignored).
    FORCED_SWITCHES = ["accept-disclaimer", "log-json", "disable-debug-logfile", "no-web-ui"]

    #: The list of options which are ignored if given in
    #: <scenario definition file>.nodes.[node_options|default_options].
    #: They are either passed by using a different configuration section in the
    #: scenario definition file, or generated by the Scenario Player itself.
    FORCED_OPTIONS = [
        "datadir",
        "log-file",
        "network-id",
        "gas-price",
        "address",
        "keystore-path",
        "password-file",
    ]

    def __init__(
        self, loaded_yaml: ScenarioYAML, index: int, chain: str, client_addr: str, run_number: int
    ):
        self._yaml = loaded_yaml
        self._chain = chain
        self.index = index
        self.run_number = run_number
        self._eth_address = client_addr
        self._api_address = None
        self._keystore = None

    def render_options(
        self, data_dir: pathlib.Path, network_id: str, log_file: pathlib.Path, **options
    ) -> List[str]:
        """Create a list of CLI options with a double dash prepended to them.

        Creates a list of strings, representing the command line argument.

        An option starts with a double dash (`--`), and is followed by one or
        more values.

        In order to pass multiple values to a an option, the values must be
        defined as a list in the relevant section of the scenario definition file.
        """
        forced_options = {
            "data-dir": data_dir,
            "keystore-path": self.keystore,
            "address": self.address,
            "password-file": self.password_file,
            "network-id": network_id,
            "gas-price": self._yaml.settings.gas_price,
            "log-file": log_file,
            "api-address": self.api_address,
        }
        optional_options = {key: self.get_option(key) for key in options}

        rendered = []
        for d in [forced_options, optional_options]:
            for option, value in d.items():
                if isinstance(value, list):
                    # Some options take several arguments given as a list. Unpack them.
                    rendered.extend([f"--{option}", *value])
                else:
                    rendered.extend([f"--{option}", value])

        return rendered

    def render_switches(self) -> List[str]:
        """Create a list of cli switches with a prepended double dash each.

        This sets all switches defined in :attr:`.FORCED_SWITCHES` by default.

        In addition, any switches stated in :attr:`.CONFIGURABLE_SWITCHES` may
        be defined in the scenario definition file, and if its value is truthy,
        the `--sync-check` switch will be passed as well.
        """
        forced_switches = self.FORCED_SWITCHES
        optional_switches = []
        return [f"--{switch}" for switch in [*forced_switches, *optional_switches]]

    def as_cli_command(
        self, chain_id: str, data_dir: pathlib.Path, log_file: pathlib.Path
    ) -> List[str]:
        """Render the set options in the scenario definitions as CLI flags for the Raiden Client.

        Distinguishes between switches (flags which take no value) and options
        (flags which do take values).

        Both types have a small sub-set of pre-defined, hard-coded and non-overridable
        switches and options. See the class attributes  :attr:`.FORCED_SWITCHES`
        and :attr:`.FORCED_OPTIONS` for non-configurable switches and options,
        respectively.
        """
        executable = self.executable.path.absolute()
        switches = self.render_switches()
        options = self.render_options(data_dir, chain_id, log_file)
        return [executable, *switches, *options]

    def get_option(self, key) -> Optional[Union[OPTION_TYPE, str]]:
        """Return a configured option.

        Looks for a config named `key` in the following order:

            1. `<ScenarioYAML>.nodes.node-options[node_index]`
            2. `<ScenarioYAML>.nodes.default-options`
            3. Another part of `<ScenarioYAML>`, if applicable.

        If the value of the option is `None`, we assume it to be a switch, aka
        a cli option without a narg, and return :var:`.IS_SWITCH`.

        Otherwise, we return the value as is.

        If the option was not set, the return value will be :var:`.MISSING_OPTION`.

        Some options may be looked up from other parts of the scenario definition
        file, if they are not stated in the `nodes` configuration section.
        """
        DEFAULT = OPTION_TYPE.MISSING

        try:
            return self._yaml.nodes.node_options[self.index][key]
        except (IndexError, KeyError):
            # Some options may be defined in other parts of the scenario definition
            # file; make sure to load them from those sections, but only as a
            # fallback value.
            if key == "pathfinding-service-address":
                DEFAULT = self._yaml.settings.services.pfs.url
            if key == "gas-price":
                DEFAULT = self._yaml.settings.gas_price
            option = self._yaml.nodes.default_options.get(key, DEFAULT)
            if option is None or isinstance(option, bool):
                # This is a switch, return an adequate sentinel value.
                return OPTION_TYPE.SWITCH.value
            return option

    # ####################### #
    # Overridable CLI Options #
    # ####################### #

    @property
    def api_address(self) -> NetlocWithPort:
        """Returns the host:port pair to expose this Raiden Client Node's API on.

        Looks for a config key named `api-address` in the following order:

            1. `<ScenarioYAML>.nodes.node-options[node_index]`
            2. `<ScenarioYAML>.nodes.default-options`

        Typically, we would ignore a CLI option which is not set in the scenario
        definition file, but since this option includes a port binding, we need
        to make sure there are no port conflicts (which there would be, as the
        default would be identical on all node start ups if left un-configured).

        If no option is given, we find a random free port and return `127.0.0.1:<port>`.

        .. note::

            There is a race condition between detecting a free port and actually
            starting the client node.
        """
        if not self._api_address:
            self._api_address = self.get_option("api-address")

            if self._api_address is OPTION_TYPE.MISSING:
                # Since we need at least two Raiden Nodes running, we cannot let
                # the Raiden Client use its default value.
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.bind(("127.0.0.1", 0))
                    self._api_address = NetlocWithPort(f"127.0.0.1:{sock.getsockname()[1]}")
        return self._api_address

    @property
    def executable(self) -> RaidenExecutable:
        """Return the path to the raiden executable.

        The value of key <ScenarioYAML>.nodes.raiden_version` decides how this is procured:

            - `LOCAL` will fetch the raiden executable on PATH, using
              :func:`shutil.which`.
            - `LATEST` will download, extract and install a raiden executable
               from the raiden cloud.
            - `x.y.z` will download, extract and install a raiden executable that
              matches the given version from the raiden cloud.

        Once procured, a :class:`pathlib.Path` object pointing to the executable is returned.

        :raises NotInstalled: if we cannot find an executable for raiden when specififying `LOCAL`.
        """

    # ########################### #
    # Non-Overridable CLI Options #
    # ########################### #

    @property
    def address(self) -> ChecksumAddress:
        """The ethereum address of the account being managed by this instance.

        This is generated by the SP automatically, and cannot be set in the
        scenario definition file.

        The value returned is equivalent to the :attr:`Path.stem` of the :attr:`.keystore` property
        passed to :func:`eth_utils.addresses.to_checksum_address`.
        """
        return to_checksum_address(self.keystore.stem)

    @property
    def keystore(self) -> pathlib.Path:
        """Return the path pointing to the Keystore file of the account managed by this instance.

        The keystore is created if it does not exist.

        The password of a newly created keystore always uses the value of :attr:`.password`.

        The name of the keystore file is `<checksum address of account>.wallet`.
        """
        if not self._keystore:
            self._keystore = create_keystore(
                run_number=self.run_number,
                index=self.index,
                scenario_name=self._yaml.name,
                password=self.password,
            )
        return self._keystore

    @property
    def password(self) -> str:
        """Return the password of the keystore.

        This is always an empty string.
        """
        return str()

    @property
    def password_file(self) -> pathlib.Path:
        """Return the path to the password file for the account managed by this instance.

        The password file is expected to be `<checksum address of account>.password`, and
        created under that name it if does not exist.

        This creates a new file in the datadir of this instance, if no password file exists.

        The password written to a created password.txt is always equivalent to
        :attr:`.password`'s value.

        When creating a password file, we always use :attr:`.address` as the stem of the file,
        appending `.password` to it.
        """
